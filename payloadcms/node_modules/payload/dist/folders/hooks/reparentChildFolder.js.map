{"version":3,"sources":["../../../src/folders/hooks/reparentChildFolder.ts"],"sourcesContent":["import type { CollectionAfterChangeHook, Payload } from '../../index.js'\n\nimport { extractID } from '../../utilities/extractID.js'\n\ntype Args = {\n  folderFieldName: string\n  folderID: number | string\n  parentIDToFind: number | string\n  payload: Payload\n}\n\n/**\n * Determines if a child folder belongs to a parent folder by\n * recursively checking upwards through the folder hierarchy.\n */\nasync function isChildOfFolder({\n  folderFieldName,\n  folderID,\n  parentIDToFind,\n  payload,\n}: Args): Promise<boolean> {\n  const parentFolder = await payload.findByID({\n    id: folderID,\n    collection: payload.config.folders.slug,\n  })\n\n  const parentFolderID = parentFolder[folderFieldName]\n    ? extractID(parentFolder[folderFieldName])\n    : undefined\n\n  if (!parentFolderID) {\n    // made it to the root\n    return false\n  }\n\n  if (parentFolderID === parentIDToFind) {\n    // found match, would be cyclic\n    return true\n  }\n\n  return isChildOfFolder({\n    folderFieldName,\n    folderID: parentFolderID,\n    parentIDToFind,\n    payload,\n  })\n}\n\n/**\n * If a parent is moved into a child folder, we need to re-parent the child\n * \n * @example\n * \n * ```ts\n    → F1\n      → F2\n        → F2A\n      → F3\n\n  Moving F1 → F2A becomes:\n\n    → F2A\n      → F1\n        → F2\n        → F3\n  ```\n */\nexport const reparentChildFolder = ({\n  folderFieldName,\n}: {\n  folderFieldName: string\n}): CollectionAfterChangeHook => {\n  return async ({ doc, previousDoc, req }) => {\n    if (previousDoc[folderFieldName] !== doc[folderFieldName] && doc[folderFieldName]) {\n      const newParentFolderID = extractID(doc[folderFieldName])\n      const isMovingToChild = newParentFolderID\n        ? await isChildOfFolder({\n            folderFieldName,\n            folderID: newParentFolderID,\n            parentIDToFind: doc.id,\n            payload: req.payload,\n          })\n        : false\n\n      if (isMovingToChild) {\n        // if the folder was moved into a child folder, the child folder needs\n        // to be re-parented with the parent of the folder that was moved\n        await req.payload.update({\n          id: newParentFolderID,\n          collection: req.payload.config.folders.slug,\n          data: {\n            [folderFieldName]: previousDoc[folderFieldName]\n              ? extractID(previousDoc[folderFieldName])\n              : null,\n          },\n          req,\n        })\n      }\n    }\n  }\n}\n"],"names":["extractID","isChildOfFolder","folderFieldName","folderID","parentIDToFind","payload","parentFolder","findByID","id","collection","config","folders","slug","parentFolderID","undefined","reparentChildFolder","doc","previousDoc","req","newParentFolderID","isMovingToChild","update","data"],"mappings":"AAEA,SAASA,SAAS,QAAQ,+BAA8B;AASxD;;;CAGC,GACD,eAAeC,gBAAgB,EAC7BC,eAAe,EACfC,QAAQ,EACRC,cAAc,EACdC,OAAO,EACF;IACL,MAAMC,eAAe,MAAMD,QAAQE,QAAQ,CAAC;QAC1CC,IAAIL;QACJM,YAAYJ,QAAQK,MAAM,CAACC,OAAO,CAACC,IAAI;IACzC;IAEA,MAAMC,iBAAiBP,YAAY,CAACJ,gBAAgB,GAChDF,UAAUM,YAAY,CAACJ,gBAAgB,IACvCY;IAEJ,IAAI,CAACD,gBAAgB;QACnB,sBAAsB;QACtB,OAAO;IACT;IAEA,IAAIA,mBAAmBT,gBAAgB;QACrC,+BAA+B;QAC/B,OAAO;IACT;IAEA,OAAOH,gBAAgB;QACrBC;QACAC,UAAUU;QACVT;QACAC;IACF;AACF;AAEA;;;;;;;;;;;;;;;;;;CAkBC,GACD,OAAO,MAAMU,sBAAsB,CAAC,EAClCb,eAAe,EAGhB;IACC,OAAO,OAAO,EAAEc,GAAG,EAAEC,WAAW,EAAEC,GAAG,EAAE;QACrC,IAAID,WAAW,CAACf,gBAAgB,KAAKc,GAAG,CAACd,gBAAgB,IAAIc,GAAG,CAACd,gBAAgB,EAAE;YACjF,MAAMiB,oBAAoBnB,UAAUgB,GAAG,CAACd,gBAAgB;YACxD,MAAMkB,kBAAkBD,oBACpB,MAAMlB,gBAAgB;gBACpBC;gBACAC,UAAUgB;gBACVf,gBAAgBY,IAAIR,EAAE;gBACtBH,SAASa,IAAIb,OAAO;YACtB,KACA;YAEJ,IAAIe,iBAAiB;gBACnB,sEAAsE;gBACtE,iEAAiE;gBACjE,MAAMF,IAAIb,OAAO,CAACgB,MAAM,CAAC;oBACvBb,IAAIW;oBACJV,YAAYS,IAAIb,OAAO,CAACK,MAAM,CAACC,OAAO,CAACC,IAAI;oBAC3CU,MAAM;wBACJ,CAACpB,gBAAgB,EAAEe,WAAW,CAACf,gBAAgB,GAC3CF,UAAUiB,WAAW,CAACf,gBAAgB,IACtC;oBACN;oBACAgB;gBACF;YACF;QACF;IACF;AACF,EAAC"}